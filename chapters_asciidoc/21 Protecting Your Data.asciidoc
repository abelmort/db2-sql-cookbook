== Protecting Your Data

There is no use having a database if the data in it is not valid. This chapter introduces some of the tools that exist in Db2 to enable one to ensure the validity of the data in your application.

*Issues Covered*

* Enforcing field uniqueness.
* Enforcing field value ranges.
* Generating key and values.
* Maintaining summary columns.
* Enforcing relationships between and within tables.
* Creating columns that have current timestamp of last change.

*Issues Not Covered*

* Data access authorization.
* Recovery and backup.

=== Sample Application

Consider the following two tables, which make up a very simple application:

.Sample application tables
[source,sql]
....
CREATE TABLE customer_balance
( cust_id        INTEGER
, cust_name      VARCHAR(20)
, cust_sex       CHAR(1)
, num_sales      SMALLINT
, total_sales    DECIMAL(12, 2)
, master_cust_id INTEGER
, cust_insert_ts TIMESTAMP
, cust_update_ts TIMESTAMP);

CREATE TABLE us_sales
( invoice#       INTEGER
, cust_id        INTEGER
, sale_value     DECIMAL(18, 2)
, sale_insert_ts TIMESTAMP
, sale_update_ts TIMESTAMP);
....

=== Customer Balance Table

We want Db2 to enforce the following business rules:

* CUST_ID will be a unique positive integer value, always ascending, never reused, and automatically generated by Db2. This field cannot be updated by a user.
* CUST_NAME has the customer name. It can be anything, but not blank.
* CUST_SEX must be either "M" or "F".
* NUM_SALES will have a count of the sales (for the customer), as recorded in the related US-sales table. The value will be automatically maintained by Db2. It cannot be updated directly by a user.
* TOTAL_SALES will have the sum sales (in US dollars) for the customer. The value will be automatically updated by Db2. It cannot be updated directly by a user.
* MASTER_CUST_ID will have, if there exists, the customer-ID of the customer that this customer is a dependent of. If there is no master customer, the value is null. If the master customer is deleted, this row will also be deleted (if possible).
* CUST_INSERT_TS has the timestamp when the row was inserted. The value is automatically generated by Db2. Any attempt to change will induce an error.
* CUST_UPDATE_TS has the timestamp when the row, or a dependent US_SALES row, was last updated by a user. The value is automatically generated by Db2. Any attempt to change directly will induce an error.
* A row can only be deleted when there are no corresponding rows in the US-sales table (i.e. for the same customer).

*US Sales Table*

We want Db2 to enforce the following business rules:

* INVOICE#: will be a unique ascending integer value. The uniqueness will apply to the US-sales table, plus any international sales tables (i.e. to more than one table).
* CUST_ID is the customer ID, as recorded in the customer-balance table. No row can be inserted into the US-sales table except that there is a corresponding row in the customerbalance table. Once inserted, this value cannot be updated.
* SALE_VALUE is the value of the sale, in US dollars. When a row is inserted, this value is added to the related total-sales value in the customer-balance table. If the value is subsequently updated, the total-sales value is maintained in sync.
* SALE_INSERT_TS has the timestamp when the row was inserted. The value is automatically generated by Db2. Any attempt to change will induce an error.
* SALE_UPDATE_TS has the timestamp when the row was last updated. The value is automatically generated by Db2. Any attempt to change will induce an error.
* Deleting a row from the US-sales table has no impact on the customer-balance table (i.e. the total-sales is not decremented). But a row can only be deleted from the latter when there are no more related rows in the US-sales table.

=== Enforcement Tools

To enforce the above business rules, we are going to have to use:

* Unique indexes.
* Secondary non-unique indexes (needed for performance).
* Primary and foreign key definitions.
* User-defined distinct data types.
* Nulls-allowed and not-null columns.
* Column value constraint rules.
* Before and after triggers.
* Generated row change timestamps.
* Distinct Data Types

Two of the fields are to contain US dollars, the implication being the data in these columns should not be combined with columns that contain Euros, or Japanese Yen, or my shoe size. To this end, we will define a distinct data type for US dollars:

.Create US-dollars data type
[source,sql]
....
CREATE DISTINCT TYPE us_dollars
AS decimal(18, 2) WITH COMPARISONS;
....

See <<distinct.types>> for a more detailed discussion of this topic.

=== Customer-Balance Table

Now that we have defined the data type, we can create our first table:

.Customer-Balance table DDL
[source,sql]
....
CREATE TABLE customer_balance
( cust_id        INTEGER NOT NULL 
                        GENERATED ALWAYS AS IDENTITY
                       ( START WITH 1
                       , INCREMENT BY 1
                       , NO CYCLE
                       , NO CACHE)
, cust_name      VARCHAR(20) NOT NULL
, cust_sex       CHAR(1) NOT NULL
, num_sales      SMALLINT NOT NULL
, total_sales    us_dollars NOT NULL
, master_cust_id INTEGER
, cust_insert_ts TIMESTAMP NOT NULL
, cust_update_ts TIMESTAMP NOT NULL
, PRIMARY KEY (cust_id)
, CONSTRAINT c1 CHECK (cust_name <> '')
, CONSTRAINT c2 CHECK (cust_sex = 'F' OR cust_sex = 'M')
, CONSTRAINT c3 FOREIGN KEY (master_cust_id)
    REFERENCES customer_balance (cust_id)
    ON DELETE CASCADE);
....

The following business rules are enforced above:

* The customer-ID is defined as an identity column (see <<identity.columns.chapter>>), which means that the value is automatically generated by Db2 using the rules given. The field cannot be updated by the user.
* The customer-ID is defined as the primary key, which automatically generates a unique index on the field, and also enables us to reference the field using a referential integrity rule. Being a primary key prevents updates, but we had already prevented them because the field is an identity column.
* The total-sales column uses the type us-dollars.
* Constraints C1 and C2 enforce two data validation rules.
* Constraint C3 relates the current row to a master customer, if one exists. Furthermore, if the master customer is deleted, this row is also deleted.
* All of the columns, except for the master-customer-id, are defined as NOT NULL, which means that a value must be provided. 
We still have several more business rules to enforce - relating to automatically updating fields and/or preventing user updates. These will be enforced using triggers.

=== US-Sales Table

Now for the related US-sales table:

.US-Sales table DDL
[source,sql]
....
CREATE TABLE us_sales
( invoice# INTEGER NOT NULL
, cust_id INTEGER NOT NULL
, sale_value us_dollars NOT NULL
, sale_insert_ts TIMESTAMP NOT NULL
, sale_update_ts TIMESTAMP NOT NULL
                           GENERATED ALWAYS
                           FOR EACH ROW ON UPDATE
                           AS ROW CHANGE TIMESTAMP

, PRIMARY KEY (invoice#)
, CONSTRAINT u1 CHECK (sale_value > us_dollars(0))
, CONSTRAINT u2 FOREIGN KEY (cust_id) 
      REFERENCES customer_balance
      ON DELETE RESTRICT);

COMMIT;

CREATE INDEX us_sales_cust ON us_sales (cust_id);
....

The following business rules are enforced above:

* The invoice# is defined as the primary key, which automatically generates a unique index on the field, and also prevents updates.
* The sale-value uses the type us-dollars.
* Constraint U1 checks that the sale-value is always greater than zero.
* Constraint U2 checks that the customer-ID exists in the customer-balance table, and also prevents rows from being deleted from the latter if there is a related row in this table.
* All of the columns are defined as NOT NULL, so a value must be provided for each.
* A secondary non-unique index is defined on customer-ID, so that deletes to the customerbalance table (which require checking this table for related customer-ID rows) are as efficient as possible.
* The CUST_UPDATE_TS column is generated always (by Db2) and gets a unique value that is the current timestamp.

==== Generated Always Timestamp Columns

A TIMESTAMP column that is defined as GENERATED ALWAYS will get a value that is unique for all rows in the table. This value will usually be the CURRENT TIMESTAMP of the last insert or update of the row. However, if more than row was inserted or updated in a single stmt, the secondary rows (updated) will get a value that is equal to the CURRENT TIMESTAMP special register, plus "n" microseconds, where "n" goes up in steps of 1. One consequence of the above logic is that some rows changed will get a timestamp value that is ahead of the CURRENT TIMESTAMP special register. This can cause problems if one is relying on this value to find all rows that were changed before the start of the query. To illustrate, imagine that one inserted multiple rows (in a single insert) into the US_SALES table, and then immediately ran the following query: 

.Select run after multi-row insert
[source,sql]
....
SELECT *
FROM us_sales
WHERE sale_update_ts <= CURRENT TIMESTAMP;
....

In some environments (e.g. Windows) the CURRENT TIMESTAMP special register value may be the same from one stmt to the next. If this happens, the above query will find the first row just inserted, but not any subsequent rows, because their SALE_UPDATE_TS value will be greater than the CURRENT TIMESTAMP special register.

Certain restrictions apply:

* Only one TIMESTAMP column can be defined GENERATED ALWAYS per table. The column must be defined NOT NULL.
* The TIMESTAMP column is updated, even if no other value in the row changes. So if one does an update that sets SALE_VALUE = SALE_VALUE + 0, the SALE_UPDATE_TS column will be updated on all matching rows.

The ROW CHANGE TIMESTAMP special register can be used get the last time that the row was updated, even when one does not know the name of the column that holds this data:

.Row change timestamp usage
[source,sql]
....
SELECT ROW CHANGE TIMESTAMP FOR us_sales
FROM us_sales
WHERE invoice# = 5;
....

The (unique) TIMESTAMP value obtained above can be used to validate that the target row has not been updated when a subsequent UPDATE is done:

.Update that checks for intervening updates
[source,sql]
....
UPDATE us_sales
SET sale_value = DECIMAL(sale_value) + 1
WHERE invoice# = 5
AND ROW CHANGE TIMESTAMP for us_sales = '2007-11-10-01.02.03';
....

==== Triggers

Triggers can sometimes be quite complex little programs. If coded incorrectly, they can do an amazing amount of damage. As such, it pays to learn quite a lot before using them. Below are some very brief notes, but please refer to the official Db2 documentation for a more detailed description. See also page 333 for a brief chapter on triggers. Individual triggers are defined on a table, and for a particular type of DML statement:

* Insert
* Update
* Delete

A trigger can be invoked once per:

* Row changed.
* Statement run.

A trigger can be invoked:

* Before the change is made.
* After the change is made.

Before triggers change input values before they are entered into the table and/or flag an error. After triggers do things after the row is changed. They may make more changes (to the target table, or to other tables), induce an error, or invoke an external program. SQL statements that select the changes made by DML (see <<insert.examples>>) cannot see the changes made by an after trigger if those changes impact the rows just changed.
The action of one "after" trigger can invoke other triggers, which may then invoke other triggers, and so on. Before triggers cannot do this because they can only act upon the input values of the DML statement that invoked them. When there are multiple triggers for a single table/action, each trigger is run for all rows before the next trigger is invoked - even if defined "for each row". Triggers are invoked in the order that they were created.

==== Customer-Balance - Insert Trigger

For each row inserted into the Customer-Balance table we need to do the following:

* Set the num-sales to zero.
* Set the total-sales to zero.
* Set the update-timestamp to the current timestamp.
* Set the insert-timestamp to the current timestamp.

All of this can be done using a simple before trigger:

.Set values during insert
[source,sql]
....
CREATE TRIGGER cust_balance_ins1
NO CASCADE BEFORE INSERT
ON customer_balance
REFERENCING NEW AS nnn
FOR EACH ROW
MODE Db2SQL
SET nnn.num_sales = 0
  , nnn.total_sales = 0
  , nnn.cust_insert_ts = CURRENT TIMESTAMP
  , nnn.cust_update_ts = CURRENT TIMESTAMP;
....

==== Customer-Balance - Update Triggers

For each row updated in the Customer-Balance table we need to do:

* Set the update-timestamp to the current timestamp.
* Prevent updates to the insert-timestamp, or sales fields.
* We can use the following trigger to maintain the update-timestamp:

.Set update-timestamp during update
[source,sql]
....
CREATE TRIGGER cust_balance_upd1 
NO CASCADE BEFORE UPDATE OF cust_update_ts 
ON customer_balance 
REFERENCING NEW AS nnn 
FOR EACH ROW
MODE Db2SQL 
SET nnn.cust_update_ts = CURRENT TIMESTAMP;
....

We can prevent updates to the insert-timestamp with the following trigger:

.Prevent update of insert-timestamp
[source,sql]
....
CREATE TRIGGER cust_balance_upd2
NO CASCADE BEFORE UPDATE OF cust_insert_ts
ON customer_balance
FOR EACH ROW
MODE Db2SQL
SIGNAL SQLSTATE VALUE '71001'
SET MESSAGE_TEXT = 'Cannot update CUST insert-ts';
....

We don't want users to update the two sales counters directly. But the two fields do have to be updated (by a trigger) whenever there is a change to the us-sales table. The solution is to have a trigger that prevents updates if there is no corresponding row in the us-sales table where the update-timestamp is greater than or equal to the current timestamp:

.Prevent update of sales fields
[source,sql]
....
CREATE TRIGGER cust_balance_upd3
NO CASCADE BEFORE UPDATE OF num_sales
                          , total_sales
ON customer_balance
REFERENCING NEW AS nnn
FOR EACH ROW
MODE Db2SQL
WHEN (CURRENT TIMESTAMP > (SELECT MAX(sss.sale_update_ts)
                           FROM us_sales sss
                           WHERE nnn.cust_id = sss.cust_id))
  SIGNAL SQLSTATE VALUE '71001'
  SET MESSAGE_TEXT = 'Feilds only updated via US-Sales';
....

==== US-Sales - Insert Triggers

For each row inserted into the US-sales table we need to do the following:

* Determine the invoice-number, which is unique over multiple tables.
* Set the update-timestamp to the current timestamp.
* Set the insert-timestamp to the current timestamp.
* Add the sale-value to the existing total-sales in the customer-balance table.
* Increment the num-sales counter in the customer-balance table.

The invoice-number is supposed to be unique over several tables, so we cannot generate it using an identity column. Instead, we have to call the following external sequence:

.Define sequence
[source,sql]
....
CREATE SEQUENCE us_sales_seq AS INTEGER
    START WITH 1
    INCREMENT BY 1
    NO CYCLE
    NO CACHE
    ORDER;
....

Once we have the above, the following trigger will take of the first three items:

.Insert trigger
[source,sql]
....
CREATE TRIGGER us_sales_ins1
NO CASCADE BEFORE INSERT
ON us_sales
REFERENCING NEW AS nnn
FOR EACH ROW
MODE Db2SQL
  SET nnn.invoice# = NEXTVAL FOR us_sales_seq
    , nnn.sale_insert_ts = CURRENT TIMESTAMP;
....

We need to use an "after" trigger to maintain the two related values in the Customer-Balance table. This will invoke an update to change the target row:

.Propagate change to Customer-Balance table
[source,sql]
....
CREATE TRIGGER sales_to_cust_ins1
AFTER INSERT ON us_sales 
REFERENCING NEW AS nnn
FOR EACH ROW
MODE Db2SQL
UPDATE customer_balance ccc
  SET ccc.num_sales = ccc.num_sales + 1
    , ccc.total_sales = DECIMAL(ccc.total_sales) + DECIMAL(nnn.sale_value)
  WHERE ccc.cust_id = nnn.cust_id;
....

==== US-Sales - Update Triggers

For each row updated in the US-sales table we need to do the following:

* Prevent the customer-ID or insert-timestamp from being updated.
* Propagate the change to the sale-value to the total-sales in the customer-balance table.

The next trigger prevents updates to the Customer-ID and insert-timestamp:

.Prevent updates to selected columns
[source,sql]
....
CREATE TRIGGER us_sales_upd2
NO CASCADE BEFORE UPDATE OF cust_id
                          , sale_insert_ts
ON us_sales
FOR EACH ROW
MODE Db2SQL
  SIGNAL SQLSTATE VALUE '71001'
  SET MESSAGE_TEXT = 'Can only update sale_value';
....

We need to use an "after" trigger to maintain sales values in the Customer-Balance table:

.Propagate change to Customer-Balance table
[source,sql]
....
CREATE TRIGGER sales_to_cust_upd1
AFTER UPDATE OF sale_value
ON us_sales
REFERENCING NEW AS nnn
            OLD AS ooo
FOR EACH ROW
MODE Db2SQL
UPDATE customer_balance ccc
    SET ccc.total_sales = DECIMAL(ccc.total_sales)
                        - DECIMAL(ooo.sale_value)
                        + DECIMAL(nnn.sale_value)
WHERE ccc.cust_id = nnn.cust_id;
....

=== Conclusion

The above application will now have logically consistent data. There is, of course, nothing to prevent an authorized user from deleting all rows, but whatever rows are in the two tables will obey the business rules that we specified at the start.

Tools Used

* Primary key - to enforce uniqueness, prevent updates, enable referential integrity.
* Unique index - to enforce uniqueness.
* Non-unique index - for performance during referential integrity check.
* Sequence object - to automatically generate key values for multiple tables.
* Identity column - to automatically generate key values for 1 table.
* Not-null columns - to prevent use of null values.
* Column constraints - to enforce basic domain-range rules.
* Distinct types - to prevent one type of data from being combined with another type.
* Referential integrity - to enforce relationships between rows/tables, and to enable cascading deletes when needed.
* Before triggers - to prevent unwanted changes and set certain values.
* After triggers - to propagate valid changes.
* Automatically generated timestamp value that is always the current timestamp or (in the case of a multi-row update), the current timestamp plus a few microseconds.


